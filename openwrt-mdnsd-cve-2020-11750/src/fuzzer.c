/* This is a modified version of:
 * https://git.openwrt.org/?p=project/mdnsd.git;a=blob_plain;f=dns.c;hb=45c4953b602962ae7ff335d9a346000f00680952
 */

#include <stdint.h>
#include <alloca.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <resolv.h>

struct interface {
    int dummy;
};

#define DBG(...)
#define fprintf(...)
#define perror(...)

#define MAX_NAME_LEN    128
#define HOSTNAME_LEN    256

#define IS_COMPRESSED(x)    ((x & 0xc0) == 0xc0)
#define CLASS_FLUSH        0x8000
#define CLASS_UNICAST        0x8000
#define CLASS_IN        0x0001
#define FLAG_RESPONSE        0x8000

#define C_DNS_SD        "_services._dns-sd._udp.local"
#define TYPE_A            0x0001
#define TYPE_PTR        0x000C
#define TYPE_TXT        0x0010
#define TYPE_AAAA        0x001c
#define TYPE_SRV        0x0021
#define TYPE_ANY        0x00ff

static char name_buffer[MAX_NAME_LEN + 1];

struct dns_answer {
    uint16_t type;
    uint16_t class;
    uint32_t ttl;
    uint16_t rdlength;
} __attribute__((packed));

struct dns_question {
    uint16_t type;
    uint16_t class;
} __attribute__((packed));

char umdns_host_label[HOSTNAME_LEN] = "X";
char mdns_hostname_local[HOSTNAME_LEN + 6] = "Y";

struct dns_header {
    uint16_t id;
    uint16_t flags;
    uint16_t questions;
    uint16_t answers;
    uint16_t authority;
    uint16_t additional;
};

static int
scan_name(const uint8_t *buffer, int len)
{
    int offset = 0;

    while (len && (*buffer != '\0')) {
        int l = *buffer;

        if (IS_COMPRESSED(l))
            return offset + 2;

        len -= l + 1;
        offset += l + 1;
        buffer += l + 1;
    }

    if (!len || !offset || (*buffer != '\0'))
        return -1;

    return offset + 1;
}

static struct dns_answer*
dns_consume_answer(uint8_t **data, int *len)
{
    struct dns_answer *a = (struct dns_answer *) *data;

    if (*len < sizeof(struct dns_answer))
        return NULL;

#if 0
    a->type = be16_to_cpu(a->type);
    a->class = be16_to_cpu(a->class);
    a->ttl = be32_to_cpu(a->ttl);
    a->rdlength = be16_to_cpu(a->rdlength);
#endif

    *len -= sizeof(struct dns_answer);
    *data += sizeof(struct dns_answer);

    return a;
}

/* This function was taken from musl libc */
int x__dn_expand(const unsigned char *base, const unsigned char *end, const unsigned char *src, char *dest, int space)
{
	const unsigned char *p = src;
	char *dend, *dbegin = dest;
	int len = -1, i, j;
	if (p==end || space <= 0) return -1;
	dend = dest + (space > 254 ? 254 : space);
	/* detect reference loop using an iteration counter */
	for (i=0; i < end-base; i+=2) {
		/* loop invariants: p<end, dest<dend */
		if (*p & 0xc0) {
			if (p+1==end) return -1;
			j = ((p[0] & 0x3f) << 8) | p[1];
			if (len < 0) len = p+2-src;
			if (j >= end-base) return -1;
			p = base+j;
		} else if (*p) {
			if (dest != dbegin) *dest++ = '.';
			j = *p++;
			if (j >= end-p || j >= dend-dest) return -1;
			while (j--) *dest++ = *p++;
		} else {
			*dest = 0;
			if (len < 0) len = p+1-src;
			return len;
		}
	}
	return -1;
}

static char *
dns_consume_name(const uint8_t *base, int blen, uint8_t **data, int *len)
{
    int nlen = scan_name(*data, *len);

    if (nlen < 1)
        return NULL;

    if (x__dn_expand(base, base + blen, *data, name_buffer, MAX_NAME_LEN) < 0) {
        perror("dns_consume_name/dn_expand");
        return NULL;
    }

    *len -= nlen;
    *data += nlen;

    return name_buffer;
}

static int parse_answer(struct interface *iface, struct sockaddr *from,
            uint8_t *buffer, int len, uint8_t **b, int *rlen,
            int cache)
{
    char *name = dns_consume_name(buffer, len, b, rlen);
    struct dns_answer *a;
    uint8_t *rdata;

    if (!name) {
        fprintf(stderr, "dropping: bad question\n");
        return -1;
    }

    a = dns_consume_answer(b, rlen);
    if (!a) {
        fprintf(stderr, "dropping: bad question\n");
        return -1;
    }

    if ((a->class & ~CLASS_FLUSH) != CLASS_IN)
        return -1;

    rdata = *b;
    if (a->rdlength > *rlen) {
        fprintf(stderr, "dropping: bad question\n");
        return -1;
    }

    *rlen -= a->rdlength;
    *b += a->rdlength;

#if 0
    if (cache)
        cache_answer(iface, from, buffer, len, name, a, rdata, a->class & CLASS_FLUSH);
#endif

    return 0;
}

static struct dns_header*
dns_consume_header(uint8_t **data, int *len)
{
    struct dns_header *h = (struct dns_header *) *data;

    if (*len < sizeof(struct dns_header))
        return NULL;

#if 0
    h->id = be16_to_cpu(h->id);
    h->flags = be16_to_cpu(h->flags);
    h->questions = be16_to_cpu(h->questions);
    h->answers = be16_to_cpu(h->answers);
    h->authority = be16_to_cpu(h->authority);
    h->additional = be16_to_cpu(h->additional);
#endif

    *len -= sizeof(struct dns_header);
    *data += sizeof(struct dns_header);

    return h;
}

static struct dns_question*
dns_consume_question(uint8_t **data, int *len)
{
    struct dns_question *q = (struct dns_question *) *data;

    if (*len < sizeof(struct dns_question))
        return NULL;

#if 0
    q->type = be16_to_cpu(q->type);
    q->class = be16_to_cpu(q->class);
#endif

    *len -= sizeof(struct dns_question);
    *data += sizeof(struct dns_question);

    return q;
}

static void
parse_question(struct interface *iface, struct sockaddr *from, char *name, struct dns_question *q)
{
    struct sockaddr *to = NULL;
    char *host;

    /* TODO: Multicast if more than one quarter of TTL has passed */
    if (q->class & CLASS_UNICAST) {
        to = from;
#if 0
        if (iface->multicast)
            iface = iface->peer;
#endif
    }

    DBG(1, "Q -> %s %s\n", dns_type_string(q->type), name);

    switch (q->type) {
    case TYPE_ANY:
        if (!strcmp(name, mdns_hostname_local)) {
#if 0
            dns_reply_a(iface, to, announce_ttl);
            service_reply(iface, to, NULL, NULL, announce_ttl);
#endif
        }
        break;

    case TYPE_PTR:
        if (!strcmp(name, C_DNS_SD)) {
#if 0
            dns_reply_a(iface, to, announce_ttl);
            service_announce_services(iface, to, announce_ttl);
#endif
        } else {
            if (name[0] == '_') {
#if 0
                service_reply(iface, to, NULL, name, announce_ttl);
#endif
            } else {
                /* First dot separates instance name from the rest */
                char *dot = strchr(name, '.');

                if (dot) {
                    *dot = '\0';
#if 0
                    service_reply(iface, to, name, dot + 1, announce_ttl);
#endif
                    *dot = '.';
                }
            }
        }
        break;

    case TYPE_AAAA:
    case TYPE_A:
        host = strstr(name, ".local");
        if (host)
            *host = '\0';
        if (!strcmp(umdns_host_label, name))
        {
#if 0
            dns_reply_a(iface, to, announce_ttl);
#endif
        }
        break;
    };
}

void
dns_handle_packet(struct interface *iface, struct sockaddr *from, uint16_t port, uint8_t *buffer, int len)
{
    struct dns_header *h;
    uint8_t *b = buffer;
    int rlen = len;

    h = dns_consume_header(&b, &rlen);
    if (!h) {
        fprintf(stderr, "dropping: bad header\n");
        return;
    }

#if 0
    if (h->questions && !iface->multicast && port != MCAST_PORT)
        /* silently drop unicast questions that dont originate from port 5353 */
        return;
#endif

    while (h->questions-- > 0) {
        char *name = dns_consume_name(buffer, len, &b, &rlen);
        struct dns_question *q;

        if (!name) {
            fprintf(stderr, "dropping: bad name\n");
            return;
        }

        q = dns_consume_question(&b, &rlen);
        if (!q) {
            fprintf(stderr, "dropping: bad question\n");
            return;
        }

        if (!(h->flags & FLAG_RESPONSE))
            parse_question(iface, from, name, q);
    }

    if (!(h->flags & FLAG_RESPONSE))
        return;

    while (h->answers-- > 0)
        if (parse_answer(iface, from, buffer, len, &b, &rlen, 1))
            return;

    while (h->authority-- > 0)
        if (parse_answer(iface, from, buffer, len, &b, &rlen, 1))
            return;

    while (h->additional-- > 0)
        if (parse_answer(iface, from, buffer, len, &b, &rlen, 1))
            return;

}

int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    uint8_t* buffer = malloc(size);
    memcpy(buffer, data, size);
    dns_handle_packet(NULL, NULL, 1234, buffer, size);
    free(buffer);
    return 0;
}
