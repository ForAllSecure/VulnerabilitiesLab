#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/udp.h>

#define DPRINTF(...)

#define DHCP_FLAG_BROADCAST	(1 << 15)

struct ip_packet {
	struct ether_header eth;
	struct iphdr iph;
} __attribute__((packed));

enum {
	DHCP_OPTION_ROUTER = 0x03,
	DHCP_OPTION_ROUTES = 0x79,
	DHCP_OPTION_END	= 0xff,
};

struct dhcp_option {
	uint8_t code;
	uint8_t len;
	uint8_t data[];
};

struct dhcp_header {
	uint8_t op, htype, hlen, hops;
	uint32_t xit;
	uint16_t secs, flags;
	struct in_addr ciaddr, yiaddr, siaddr, giaddr;
	unsigned char chaddr[16];
	unsigned char sname[64];
	unsigned char file[128];
	uint32_t cookie;
	uint8_t option_data[];
} __attribute__((packed));

struct relayd_host {
	uint8_t ipaddr[4];
};

struct relayd_interface {
    uint8_t dummy;
};

static void relayd_add_host_route(struct relayd_host *host, const uint8_t *dest, uint8_t mask)
{
    /* dummy */
    (void)host;
    (void)dest;
    (void)mask;
}

static void relayd_add_pending_route(const uint8_t *gateway, const uint8_t *dest, uint8_t mask, int timeout)
{
    /* dummy */
    (void)gateway;
    (void)dest;
    (void)mask;
    (void)timeout;
}

static struct relayd_host *relayd_refresh_host(struct relayd_interface *rif, const uint8_t *lladdr, const uint8_t *ipaddr)
{
    /* dummy */
    (void)rif;
    (void)lladdr;
    (void)ipaddr;

    return NULL;
}

static void relayd_forward_bcast_packet(struct relayd_interface *from_rif, void *packet, int len)
{
    /* dummy */
    (void)from_rif;
    (void)packet;
    (void)len;
}

static uint16_t
chksum(uint16_t sum, const uint8_t *data, uint16_t len)
{
	const uint8_t *last;
	uint16_t t;

	last = data + len - 1;

	while(data < last) {
		t = (data[0] << 8) + data[1];
		sum += t;
		if(sum < t)
			sum++;
		data += 2;
	}

	if(data == last) {
		t = (data[0] << 8) + 0;
		sum += t;
		if(sum < t)
			sum++;
	}

	return sum;
}

static void
parse_dhcp_options(struct relayd_host *host, struct dhcp_header *dhcp, int len)
{
	uint8_t *end = (uint8_t *) dhcp + len;
	struct dhcp_option *opt = (void *)dhcp->option_data;
	static const uint8_t dest[4] = { 0, 0, 0, 0 };

	while((uint8_t *) opt < end) {
		if ((uint8_t *) opt + opt->len > end)
			break;

		opt = (void *) &opt->data[opt->len];
		switch(opt->code) {
		case DHCP_OPTION_ROUTER:
			DPRINTF(2, "Found a DHCP router option, len=%d\n", opt->len);
			if (!memcmp(opt->data, host->ipaddr, 4))
				relayd_add_host_route(host, dest, 0);
			else
				relayd_add_pending_route(opt->data, dest, 0, 10000);
			break;
		case DHCP_OPTION_ROUTES:
			DPRINTF(2, "Found a DHCP static routes option, len=%d\n", opt->len);
			break;
		case DHCP_OPTION_END:
			opt = (void *) end;
			continue;
		default:
			DPRINTF(3, "Skipping unknown DHCP option %02x\n", opt->code);
			continue;
		}

	}
}

bool relayd_handle_dhcp_packet(struct relayd_interface *rif, void *data, int len, bool forward, bool parse)
{
	struct ip_packet *pkt = data;
	struct udphdr *udp;
	struct dhcp_header *dhcp;
	struct relayd_host *host;
	int udplen;
	uint16_t sum;

	if (pkt->eth.ether_type != htons(ETH_P_IP))
		return false;

	if (pkt->iph.version != 4)
		return false;

	if (pkt->iph.protocol != IPPROTO_UDP)
		return false;

	udp = (void *) ((char *) &pkt->iph + (pkt->iph.ihl << 2));
	dhcp = (void *) (udp + 1);

	udplen = ntohs(udp->len);
	if (udplen > len - ((char *) udp - (char *) data))
		return false;

	if (udp->dest != htons(67) && udp->source != htons(67))
		return false;

	if (dhcp->op != 1 && dhcp->op != 2)
		return false;

	if (!forward)
		return true;

	if (dhcp->op == 2) {
		host = relayd_refresh_host(rif, pkt->eth.ether_shost, (void *) &pkt->iph.saddr);
		if (host && parse)
			parse_dhcp_options(host, dhcp, udplen - sizeof(struct udphdr));
	}

	DPRINTF(2, "%s: handling DHCP %s\n", rif->ifname, (dhcp->op == 1 ? "request" : "response"));

	dhcp->flags |= htons(DHCP_FLAG_BROADCAST);

	udp->check = 0;
	sum = udplen + IPPROTO_UDP;
	sum = chksum(sum, (void *) &pkt->iph.saddr, 8);
	sum = chksum(sum, (void *) udp, udplen);
	if (sum == 0)
		sum = 0xffff;

	udp->check = htons(~sum);

	relayd_forward_bcast_packet(rif, data, len);

	return true;
}

int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    if ( size < sizeof(struct ip_packet) ) {
        return 0;
    }
    uint8_t* buffer = malloc(size);
    memcpy(buffer, data, size);
    relayd_handle_dhcp_packet(NULL, buffer, size, true, true);
    free(buffer);
    return 0;
}
